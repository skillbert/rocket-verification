% need all this to get indexable bool[] ....
% i must be doing something wrong right??

map setbool: List(Bool) # Int # Bool -> List(Bool);
map getbool: List(Bool) # Int -> Bool;
map initbools: Int # Bool -> List(Bool);

var m:List(Bool);
	n:Int;
	v:Bool;

eqn n==0 -> setbool(m,n,v) = v |> tail(m);
	n!=0 -> setbool(m,n,v) = head(m) |> setbool(tail(m),n-1,v);
	n==0 -> getbool(m,n) = head(m);
	n!=0 -> getbool(m,n) = getbool(tail(m),n-1);
	n==0 -> initbools(n,v) = [];
	n!=0 -> initbools(n,v) = v |> initbools(n-1,v);


act
	%booster module
	%TODO change to number 0/1 typedef
	ignite_bm:Bool;
	stop_bm:Bool;
	confirm_bm_thrust:Bool;
	fail_bm_thrust:Bool;
	thrust_bm:Bool;

	s_startup_bm,r_startup_bm,c_startup_bm:Bool;
	s_stop_bm,r_stop_bm,c_stop_bm:Bool;
	s_confirm_bm_thrust,r_confirm_bm_thrust,c_confirm_bm_thrust:Bool;
	s_stopped_bm,r_stopped_bm,c_stopped_bm:Bool;
	s_fail_bm_thrust,r_fail_bm_thrust,c_fail_bm_thrust:Bool;

	%launch module
	ignite_lm;
	confirm_lm_thrust;
	fail_lm_thrust;
	stop_lm;
	thrust_lm;
	orbit_ok_lm;
	orbit_achieved;
	detach_ground_clamps;
	s_detach_bm,r_detach_bm,c_detach_bm:Bool;

	s_lm_abort,r_lm_abort,c_lm_abort;
	s_lm_orbit_ok,r_lm_orbit_ok,c_lm_orbit_ok;

	%orbital module
	detach_cm;
	ignite_om;
	confirm_om_thrust;
	stop_om;
	fail_om_thrust;
	thrust_om;
	orbit_ok_om;

	s_om_abort,r_om_abort,c_om_abort;
	s_om_orbit_ok,r_om_orbit_ok,c_om_orbit_ok;

	%crew module
	detach_om1;
	abort_cm;
	abort_pad;
	land_cm;
	do_space_stuff;

	%sensors
	s_check_fuel,r_check_fuel,c_check_fuel;
	s_fuel,r_fuel,c_fuel:Bool;

	s_check_alt,r_check_alt,c_check_alt;
	s_alt,r_alt,c_alt:Nat;
	
				
proc
	%@param(Bool): True: fuel full, False: fuel empty.
	%@desc: Fuel sensor for the system.
	fuelsensor = r_check_fuel . (s_fuel(true) . fuelsensor
								 + s_fuel(false) . fuelsensor);

	%@param(Bool): 1: height to detach BM, 2: height to detach LM.
	%@desc: altimeter sensor for the system
	altimeter = r_check_alt . (s_alt(1) . altimeter
							 + s_alt(2) . altimeter);

	%@param(left): True = left BM, False = right BM.
	%@param(broken): Whether the BM is broken (False) or not (True).
	%@desc: This process defines the main actions for a BM (start, stop, detach).
	BM(left:Bool,broken:Bool) =
		(!broken) -> r_startup_bm(left) . ignite_bm(left) . BM_start(left)
		+ r_stop_bm(left) . BM(left,broken)
		+ r_detach_bm(left) . BM_detachd;
	
	%@param(left): True = left BM, False = right BM.
	%@desc: This process defines the possible actions while the BM is starting (fail, stop, on).
	BM_start(left:Bool) =
		BM_fail(left) 
		+ r_stop_bm(left) . BM_stop(left)
		+ s_confirm_bm_thrust(left) . BM_on(left);
	
	%@desc: When the BM is detachd it ends in a process that cannot do anything (delta).
	BM_detachd = delta;
	
	%@param(left): True = left BM, False = right
	%@desc: This process defines the actions when the BM needs to stop which means it is broken.
	BM_stop(left:Bool) = stop_bm(left) . s_stopped_bm(left) . BM(left,false);

	%@param(left): True = left BM, False = right BM
	%@desc: This process defines the actions when a BM fails. 
	BM_fail(left:Bool) = fail_bm_thrust(left) . (s_fail_bm_thrust(left) + r_stop_bm(left) . s_stopped_bm(left)) . BM(left,true);

	%@param(left): True = left BM, False = right BM
	%@desc: When the BM is on it can thrust the engine, fail or it can be stopped. 
	BM_on(left:Bool) = 
		thrust_bm(left) . BM_on(left)
		+ BM_fail(left)
		+ r_stop_bm(left) . BM_stop(left);

	%@desc: The LM and BM startup happen in parallel. Ignite LM, BMLeft and BMRight, 
	LM_startup = (ignite_lm . s_startup_bm(true)|s_startup_bm(false)) . LM_ground(false,[false,false]);
	
	%@param(engine_on): True = engine on, False = engine off
	%@param(bm_engine): List[BMLeft, BMRight] 
	%@desc: This process checks if the LM, BMLeft and BMRight thrusters and engines or on. If this is the case the LM can launch and 
	%		proceed to the LM_fly process or if something goes wrong, the LM_ground_abort process.
	LM_ground(engine_on:Bool,bm_engine:List(Bool)) =
		  (!getbool(bm_engine,0)) -> r_confirm_bm_thrust(false) . LM_ground(engine_on,setbool(bm_engine,0,true))
		+ (!getbool(bm_engine,1)) -> r_confirm_bm_thrust(true) . LM_ground(engine_on,setbool(bm_engine,1,true))
		+ (!engine_on) -> confirm_lm_thrust . LM_ground(true,bm_engine)
		+ (engine_on && getbool(bm_engine,0) && getbool(bm_engine,1)) -> detach_ground_clamps . LM_fly
		+ (engine_on) -> thrust_lm . LM_ground(engine_on,bm_engine)
		+ (r_fail_bm_thrust(true) + r_fail_bm_thrust(false) + fail_lm_thrust) . LM_ground_abort;

	%@desc: This process defines the actions the LM performs when it is in the air (fly, abort, stop).
	LM_fly =
		thrust_lm . LM_fly
		+(r_fail_bm_thrust(true)+r_fail_bm_thrust(false)+fail_lm_thrust) . LM_abort
		+ (	s_check_alt . r_alt(1) . s_stop_bm(true)|s_stop_bm(false) . LM_stop_bm([true,true]));

	%@param(bm_on): List[BMLeft,BMRight] consisting of bools. True: BM is on, False: BM is off.
	%@desc: This process describes the actions the LM performs when it needs to stop the BMs. It gets both the BM's state in a parallel action(on or off), 
	%		If one of the booster modules failed or stopped we turn off the BM.
	LM_stop_bm(bm_on:List(Bool)) = 
		(getbool(bm_on,0) || getbool(bm_on,1)) -> (
			getbool(bm_on,0) -> (r_stopped_bm(false) + r_fail_bm_thrust(false)) . LM_stop_bm(setbool(bm_on,0,false))
			+ getbool(bm_on,1) -> (r_stopped_bm(true) + r_fail_bm_thrust(true)) . LM_stop_bm(setbool(bm_on,1,false))
			+ thrust_lm . LM_stop_bm(bm_on)
			+ fail_lm_thrust . LM_abort
		) <> LM_sep_bm([true,true]);

	%@param(bm_attached): List[BMLeft, BMRight] consisting of bools. True: BM is attached, False: BM is detached.
	%@desc: 
	
	%TODO: Hier hetzelfde verhaal, begrijp niet helemaal hoe ik dit moet interpreteren.
	LM_sep_bm(bm_attached:List(Bool)) = 
		(getbool(bm_attached,0) || getbool(bm_attached,1)) -> (
			getbool(bm_attached,0) -> s_detach_bm(false) . LM_sep_bm(setbool(bm_attached,0,false))
			+ getbool(bm_attached,1) -> s_detach_bm(true) . LM_sep_bm(setbool(bm_attached,1,false))
			+ thrust_lm . LM_sep_bm(bm_attached)
			+ LM_abort %add sep fail action
			+ fail_lm_thrust . LM_abort
		) <> s_check_alt . r_alt(2) . LM_fly_space;

	%@desc: This process defines the actions when the LM needs to abort. It stops both BMs, stops the LM and proceeds
	%		to the LM_safe process.
	LM_abort = s_lm_abort . s_stop_bm(true)|s_stop_bm(false) . stop_lm . LM_safe;

	%@desc: This process defines the actions when the LM is in space. The LM can fail resulting in an abort or it can succesfully
	%		achieve orbit in which case it stops and ends in a non-active process.
	LM_fly_space = 
		thrust_lm . LM_fly_space
		+fail_lm_thrust . s_lm_abort
		+s_check_alt . r_alt(2) . stop_lm . s_lm_orbit_ok . delta;

	%@desc: launch aborted at pad, rocket still on ground
	LM_ground_abort = s_stop_bm(true)|s_stop_bm(false) . stop_lm . abort_pad . LM_safe;

	%not 100% sure, we need to continue talking to boosters for their controllers to not hang
	LM_safe = LM_ignore_bm . LM_safe;

	%TODO remove
	LM_ignore_bm = (
			r_confirm_bm_thrust(true) + r_confirm_bm_thrust(false)
			+ r_fail_bm_thrust(true) + r_fail_bm_thrust(false) 
			%not sure about these 2
			%+ confirm_lm_thrust + fail_lm_thrust
		);

	OM_wait = r_lm_orbit_ok . OM;
	OM = detach_cm . ignite_om . (
		confirm_om_thrust . OM_fly
		+ fail_om_thrust . stop_om . s_om_abort . delta
	);
	
	OM_fly = 
		thrust_om . OM_fly
		+ fail_om_thrust . stop_om . s_om_abort . delta
		+ orbit_ok_om . s_om_orbit_ok . delta;

	%crew module
	CM = 
		(r_lm_abort + r_om_abort) . detach_om . abort_cm . CM_land
		+ r_om_orbit_ok . detach_om . orbit_achieved . do_space_stuff . CM_land;

	%TODO add sep SM, chutes, heatshield, airbags
	CM_land = land_cm . delta;
	

init allow(
	{
		ignite_bm,
		stop_bm,
		confirm_bm_thrust,
		fail_bm_thrust,
		thrust_bm,

		c_startup_bm|c_startup_bm,
		c_stop_bm|c_stop_bm,
		c_confirm_bm_thrust,
		c_fail_bm_thrust,
		c_stopped_bm,

		%launch module
		ignite_lm,
		confirm_lm_thrust,
		fail_lm_thrust,
		stop_lm,
		thrust_lm,
		orbit_ok_lm,
		orbit_achieved,
		detach_ground_clamps,
		c_detach_bm,

		c_lm_abort,
		c_lm_orbit_ok,

		%orbital module
		detach_cm,
		ignite_om,
		confirm_om_thrust,
		stop_om,
		fail_om_thrust,
		thrust_om,
		orbit_ok_om,
		
		c_om_abort,
		c_om_orbit_ok,

		%crew module
		detach_om,
		abort_cm,
		abort_pad,
		land_cm,
		do_space_stuff,

		%sensors
		c_check_alt,
		c_check_fuel,
		c_fuel,
		c_alt
	},
	comm({
		r_startup_bm|s_startup_bm -> c_startup_bm,
		r_stop_bm|s_stop_bm -> c_stop_bm,
		r_confirm_bm_thrust|s_confirm_bm_thrust -> c_confirm_bm_thrust,
		r_stopped_bm|s_stopped_bm -> c_stopped_bm,
		r_fail_bm_thrust|s_fail_bm_thrust -> c_fail_bm_thrust,
		s_lm_abort|r_lm_abort -> c_lm_abort,
		s_lm_orbit_ok|r_lm_orbit_ok -> c_lm_orbit_ok,
		s_om_abort|r_om_abort -> c_om_abort,
		s_om_orbit_ok|r_om_orbit_ok -> c_om_orbit_ok,
		s_detach_bm|r_detach_bm -> c_detach_bm,
		s_check_alt|r_check_alt->c_check_alt,
		s_check_fuel|r_check_fuel->c_check_fuel,
		s_alt|r_alt->c_alt,
		s_fuel|r_fuel->c_fuel
	},
		BM(true,false) || BM(false,false) || LM_startup || OM_wait || CM || fuelsensor || altimeter
	)
);
